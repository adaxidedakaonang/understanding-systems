## 悲观锁与乐观锁

锁之提纲
* 互斥锁
* 自旋锁
* 读写锁
* 悲观锁
* 乐观锁

### 互斥锁与自旋锁：谁更轻松自如

这两种锁是基础型款，是各种高级锁的地基

互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：
* 互斥锁加锁失败后，线程会释放CPU，给其他线程；
* 自旋锁加锁失败后，线程会忙等待，直到拿到锁；

互斥锁存在两次线程上下文切换：
1. 内核将加锁失败的线程设置为休眠；
2. 锁可用后内核唤醒线程。

*若能确定被锁住的代码执行时间很短， 就不应该用互斥锁，而应该选自旋锁。*

单核CPU上需要抢占式的调度器（通过时钟周期中断一个线程，运行其他线程）。因为自旋的线程永远不会放弃CPU。

### 读写锁：读和写也有优先级区分

>读写锁适用于能明确区分读操作和写操作的场景。

写锁是独占锁，读锁是共享锁。

读写锁在读多写少的场景，能发挥出优势。

读写锁可以分为读优先锁和写优先锁

公平读写锁：获取锁的读写线程排队，队列原则先进先出，可避免任一方饥饿现象。

### 乐观锁与悲观锁：做事心态不同。

互斥锁，自旋锁，读写锁，都属于悲观锁。

悲观锁：访问共享资源前，要先上锁

乐观锁：先编辑，再检查是否冲突。





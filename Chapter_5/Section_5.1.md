## 进程调度/页面置换/磁盘调度算法

### 进程调度算法

以下情况会发生CPU调度：
1. 进程从 运行状态->等待状态；
2. 运行状态->就绪状态；
3. 等待状态->就绪状态；
4. 运行状态->终止状态;

1,4属于非抢占式调度
2,3属于抢占式调度

调度算法只会影响等待时间，不会影响进程使用CPU的时间和io时间。

常见调度算法：
* 先来先服务调度算法
* 最短作业优先调度算法
* 高响应比优先调度算法
* 时间片轮转调度算法
* 最高优先级调度算法
* 多级反馈队列调度算法

#### 先来先服务调度算法
>非抢占式

每次从就绪队列选择最先进⼊队列的进程，然后⼀直运⾏，直到进程退出或被阻塞，才会继续从队列中选择第⼀个进程接着运⾏。

*对长作业有利，适用于CPU繁忙型作业系统，而不适用于I/O繁忙型系统*

#### 最短作业优先调度算法

优先选择运行时间最短的进程来运行

*对长作业不利*

#### 高响应比优先调度算法

（等待时间+要求服务时间 ）/ 要求服务时间

相同等待时间的任务，要求服务时间越短越优先；  
相同要求服务时间的任务，等待时间越长越优先。

#### 时间片轮转调度算法

每个进程分配一个时间段，时间段设置太长会导致短作业进程响应时间变长。时间段设置过短会导致过多进程的上下文切换，降低CPU效率。

#### 最高优先级调度算法

从就绪队列中选择最高优先级的进程进行运行

优先级分为：
* 静态优先级：创建进程的时候就已经确定，整个运行时间都不会变化。
* 动态优先级：根据进程的动态变化调整优先级，比如随着时间的推移增加等待进程的优先级。


#### 多级反馈队列调度算法

设置多个队列，赋予每个队列不同优先级。优先级越高，分配的时间片越短。

新进程会被放入第一级队列的末尾。在第一级队列时间片没运行完就去第二级队列末尾。

当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行。

**兼顾了长短作业，同时有较好响应时间。**


### 内存页面置换算法

#### 缺页异常（缺页中断）

缺页中断：
* 在指令执行期间产生和处理中断信号；
* 返回到该指令的开始重新执行该指令。

一般中断：
* 指令执行完成后检查和处理中断信号；
* 返回到该指令的下一个指令执行。

当物理内存满了之后，就需要页面置换算法来将一些修改过的物理页（脏页）换出到磁盘，将器状态改为无效，最后把正在访问的页面装入到该物理页中。

页面置换算法的功能：出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面。

页面置换算法的目标：尽可能减少页面的换入换出次数

常见的页面置换算法：
* 最佳页面置换算法
* 先进先出置换算法
* 最近最久未使用的置换算法
* 时钟页面置换算法
* 最不常用置换算法

#### 最佳页面置换算法

>置换在未来最长时间不访问的页面。

#### 先进先出置换算法

>选择在内存驻留时间很长的页面进行置换

#### 最近最久未使用的置换算法

>选择最长时间没有被访问的页面进行置换

#### 时钟页面置换算法  

>环形链表记录页表访问次数，遍历直到遇见访问次数为0的页表将其置换，同时将访问次数为1的表置0.

#### 最不常用置换算法

>当发生缺页中断时，选择访问次数最少的那个页面，并将其淘汰。

### 磁盘调度算法

常见的磁盘调度算法：
* 先来先服务算法
* 最短寻道时间优化算法
* 扫描算法
* 循环扫描算法
* LOOK与C-LOOK算法

#### 先来先服务

>简单粗暴，寻道时间长

#### 最短寻道时间优先

根据磁头当前的位置，重新排列目标磁道
>动态请求可能产生饥饿：磁头在一小块区域来回移动

#### 扫描算法

先在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后磁道，才调换方向。
>中间部分磁道响应频率较多，比较占便宜。

#### 循环扫描算法

磁道只响应一个方向上的请求，返回中途不处理任何请求。

>对于各个位置磁道响应频率相对比较平均。会移动到磁道最始端或最末端。

#### LOOK与C-LOOK算法

>与扫描、循环扫描算法相同，只是不会移动到磁道始末端，只会移动到最远请求端
